% The setting of the project is described based on the scientific literature in a balanced and comprehensive way. The content and relevance of the included literature is understood
\chapter[Background]{Background}
\label{cha:backgr}
This chapter will go over the background of this project, which will cover basic operating system fundamentals, a brief overview of the RISC-V architecture, and the specifics of the board that will be used, which is the Sifive Hifive1 RevB. By the end of the chapter, the reader should be able to understand how parts of the operating system should function, and be able to understand the RISC-V architecture in comparison to the ARM architecture.
\section{Operating System Fundamentals}
An operating system's purpose is to provide an interface between user code and the hardware, such as memory and \ac{io}, to allow the user code to function seamlessly, and allow interaction with users. This has been split into three key sections, as listed by the aims of the project, as process management, memory management and \ac{io} management.\cite{modern_operating}
\subsection{Process Management}
The process model is where all software is organised as seperate code, which is scheduled in a fashion to give the illusion of multiproccessing. While multiproccessing is possible with multiple hardware threads, this project is limited to microcontroller chips, which mainly only support a single hardware thread. To give the illusion of multiproccessing, the information to load and run individual sections of sequenctial code is stored, so that an algorithm can be used to load, run, and possibly pause these execution, to allow them to be swapped out at a rate that makes it imperceivable that they are not running concurrently. This algorithm is the scheduling algorithm, and there are several approaches to how this is handled.\cite{modern_operating}
\subsubsection{Scheduling Algorithms}
In an interactive system, processes are ran in a way that ensures each process will get a fair amount of execution time. This is done simplest using a round robin algorithm. Due to the interactive requirement, processes that take a large amount of execution time need to be pre-empted, so one process cannot halt other processes for too long. This is done mainly by pausing a running process after a certain amount of time (which is known as the algorithms quantum).
\subsection{Memory Management}
The goal of memory management is to streamline how a process can use memory, while at the same time protecting critical sections of memory from faulty or malicous user code. In a system with multiple processes being executed and no memory abstraction, there exists the possibility that two processes attempt to use the same section of memory, creating a conflict that would cause both processes to run incorrectly. This occurs as different processes cannot be aware of each other, and have no choice but to use memory without knowledge of which sections are in use. This can be solved using memory abstraction. The simplest method of this is using address spaces, where each process is given permission to access only segments of directly addressed memory. This prevents each process modifying other processes memory, and allows the process to behave individually, as long as it is provided with the location of its address space.\cite{modern_operating}
\subsection{IO Management}
\section{Information on board}
\section{RISC-V}
RISC-V is \ac{risc} \ac{isa}, built with the goal to be completly open. The ISA uses a base interger ISA which can be used on its own or with a number of optional standard extensions, which is part of a goal to avoid `over-architecting' for particular micro-architectures. There are variants for both 32 bit systems and 64 bit systems however for this project only the 32 bit system will be considered.\cite{riscv_unpriv}
\subsection{Registers}
RISC-V implenents 32 general purpose registers, which in our case will be 32 bits wide, and labeled x0 to x31. The x0 register is hardwired to zero, and all other registers may be used. There are no specific registers used for storing information like the stack pointer or return address, however in this project the standard calling convention will be used. This specifies how each register should be used, how the register should be saved, and gives each register a pseudonym which correlates to its purpose. Important registers are ra, which is used to store the return address produced by the jump and link instruction, sp and gp, which are used to store the stack pointer and the global pointer. The stack pointer is used to store the most recent item in the current processes stack, and the global pointer is used to point to the address space where a processes global variables will be stored. The collection of registers a0-a7 are used to pass arguments to functions, as well as a0 serving as a return value. For general use there are registers t0 to t6 and s0 to s11, the difference being that t0-t6 are temporary registers that are not required to have their value saved before use, whereas s0-s11 does require saving the value. This allows the use of temporary registers to store intermeddiate values or value not needed to be stored, without needed the overhead of adding them to the stack, and the saved registers allow important information not to be overwritten by called functions.\cite{riscv_unpriv}
\subsection{Base ISA}
The base ISA, known as RV32I, specifies the set of instructions that all RISC-V systems implement, which includes both priviledged and unpriveledge instructions. The load and store operations allow loading and storing one register to or from memory. This registers can be treated as a word, half word or as a byte. There are the standard arithmetic, logic and shift operations, however immediate values are limited to 12 bits, so operations such as LUI (load upper immediate) may be used to load larger immediate values into a register.\\
Unlike ARM, the RISC-V ISA does not use flags to determine conditional operations. Instead the condition that is used to determine whether a branch is taken or not is included in the branch operation itself, with instructions like BEQ (branch if equal) or BGT (brach if greater than). These are accompanied by comparison operations, which evalutate similar conditions, and produce either a 1 or a 0 in the target register. JAL (jump and link) branches to a specified location while storing a return address, which allows the implementation of subroutines and functions. 
\subsubsection{Priviledge levels}
The previously described operations can be performed in any priviledge mode. RISC-V can support up to three priviledge modes, being user, supervisor, and machine mode, although this report will only be considering user mode and machine mode. The zicsr extension adds operations that allow a hart in machine mode to read and modify \ac{csrs}, such as the CSRRW, which reads a csr to a register and writes a register to a csr, although either the source or target register can be set to zero to disable either the reading or the writing. Also included is the CSRRS and CSRRC, which is similar to CSRRW but sets or clears bits of the \ac{csrs}. 
\subsection{Optional Extensions}
% Include info on A, M, and C
\subsection{Traps}
In RISC-V, a trap refers to anything where the execution on the hart is handed to the trap handler. There are two categories of traps, synchronous and asynchronous
\subsubsection{Asynchronous/Interrupts}
An asynchronous trap is a break in execution caused by external factors, and can be referred to as an interrupt. There are three types of interrupt which are software, timer, and external. These are controlled by two units, the \ac{clint} and the \ac{plic}. The \ac{clint} handles the software and timer interrupts, and the \ac{plic} handles the external interrupts. A software interrupt is triggered when a hart sets its interrupt bit high. This is used generally for commincation between harts, and since this project will not involve more that one hart, this functionality will not be used. A timer interrupt is taken when the mtime CSR is greater than the mtimecmp CSR, so is used to generate an interrupt after a given amount of time. External interrupts are any other caused by the \ac{plic}, which can include seperate timer interrupts, or \ac{io} sourced interrupts.
% include figure from docs figure 5, interrupt architecture
\subsubsection{Synchronous}
A synchronous trap occurs in response to the execution of an instruction, which occurs with the clock, hence syncrounous. These come from two sources, errors and enviroment calls. Errors included memory misallignments, access faults and illegal instructions. This allows for these errors to handled, either to be inform the process of the error, or to remove the process. Enviroment calls are how processes make calls to the kernel to perform actions that are above the processes access level, generally to perform IO operations, or to interact with other processes.