% Testing and evaluation is very well thought through and described. The report could be used to reproduce the work.
\chapter[Evaluation]{Evaluation}
\label{cha:eval}
In this section, I will discuss the capabilities of the designed operating system with comparisons to the original concepts it was implementing to evaluate its effectiveness and completeness.
\section{Challenges}
Since this project is hardware based, there are several complications when it comes to testing that do not occur in standard software. This is because the tools available to validate programs are less available, which results on a far greater reliance on manual checking as opposed to automated testing. This problem is made worse as many of the methods of checking for correct execution are reliant on standard IO, which is not available to us as the IO itself is being developed.\\
Another challenge is the problem of developing with interrupts that are triggered by uncontrollable events, or events that need to function at a high frequency. These include timer interrupts, and external interrupts that function asynchronously like the UART. These limit the functionality of breakpoints, as often the asynchronous behaviour can continue while execution of the rest of the processor is paused, which puts the system into a state that would not occur during normal execution.
\section{Dissasembly}% find better section title
The first step to ensuring code is correct was to ensure that the assembled code was assembled and linked correctly. To facilitate this, on assembly the makefile was configured to dissasemble the generated executable, using objdump from the riscv-gnu-toolchain. This enabled me to ensure that the structure of each section was maintained, which is important as many parts of the system require memory alignment, for example in the jump tables used in the enviroment handler and the exception handler require the branch instructions to be word aligned, and that the spacing between entries is correct. The decompilation was also vital when developing the toolchain, as it allowed me to validate that the system would be loaded correctly between Flash and the DTIM.
\section{Breakpoints and Inspection}
Of the tools available to debug, one of the most powerful tools is the JTAG interface. The JTAG interface allows an external connection to access the debug CSRs of the system, which allows a host machine to control the execution and memory state of the board, through the use of breakpoints and step through execution and memory commands. To utilise this, I used GDB to load code onto the board, at which point GDB could interface via JTAG to create a similar debug enviroment on the host machine to the debug enviroment of a standard program. This allowed the use of up to eight breakpoints, the limited number due to the requirement to use the hardware breakpoints. The ability to inspect and modify memory directly was very powerful in both initial experimentation and later debugging. Since most of the system's functions are memory mapped, it allows direct inspection of the boards configuration and many IO functions, which gives a much greater insight into their function than the documentation as the information on the board is by definition fully accurate. Some examples of information is the boot state of the board, as the state of many registers is often specified as `X', which means the actual value is determined by the implementation, so it is unknown without inspection. For debiggin, memory inpection allowed me to manual verify the execution of the system. The manual verification was done in two ways; comparing data to `golden data', and comparing observed behaviour with expected behaviour. For sections which need to produce a specific output I can calculate the result before execution and compare the generated result with that, as well as observing all intermediate values. An example of this is when calculating the encoding for the PMP, so the address indicates the correct NAPOT range. This can then be followed with observing the following behaviour. In the case of the PMP range, I can use text sections of sizes that approach or exceed the size limit specified, and check that the process is or is not allowed to fetch instructions from that area. This method is especially important when testing asynchronous operations like timer interrupts, as a step by step approach does not function, so it is often to require the function to produce an additional output like an LED, so that the behaviour of the function can be observed in a real time environment.

% \section{Design Reflections}
% memory man: was the constant address space sufficient, or should another system have been implemented, like a dynamic system that include requests for heap memory, instead of providing a constant amount
% processes: was the project developed to allow for sufficient interprocess communication? programs could create forks and new processes however no design was included to allow for these to communicate after the initial creation
% Lack of method to write and user code seperately to the oa
% Limited IO, could more IO been developed to make the system more interactive, for instance use of the aduino compatable pins, or basic use of the wireless chip.
% Implemented IO, was all the functions built to function? Inputs blocked execution, was this appropriate or could a better design be made to allow this to be interrupt based
% Was the choice of interactive shceduler correct? or should of a batch system have been chosen due to the limited io of the device limiting the interactivity of the device
% Did the os function? at what rate did it execute? how did the quantum affect the interactivity